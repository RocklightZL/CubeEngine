记录整个项目的开发过程，包括想法、bug等。

从7.20开始记录（项目从7.3开始开发）。

# 7.20

开始开发CubeEditor

用**imgui**开发编辑器。

## 拖动imgui演示窗口出现拖影

原因是没有清除颜色缓冲区。

清除颜色缓冲区的代码放在了RenderSystem的更新逻辑里，而我不打算让编辑器的本身的UI渲染依赖于引擎内核的ECS架构，所以这部分代码应该放在Application循环的最开始。

# 7.21

完成了FrameBuffer封装，实现了基本的场景视图和场景面板。

## imgui复选框

checkbox第二个参数（也就是表示是否选中的bool变量指针）对应的bool变量初始化不能放在渲染循环里，否则点击复选框没反应，原因是状态每次都被重置了。

## ImGui对话框显示逻辑

OpenPopup() 将指定对话框标识为“需要显示”，即激活状态。

BeginPopup(): 当该对话框处于激活状态时返回true，显示内容，不处于激活状态时返回false，不显示。

CloseCurrentPopup(): 将当前对话框标识为“不显示”，即未激活状态。

当在一个对话框里调用OpenPopup() 意为打开一个子对话框，并且子对话框逻辑必须在父对话框内部，当父对话框退出时，子对话框也会退出。这就是不能把对话框逻辑写在右键菜单中的原因。

# 7.22

继续完善场景创建逻辑

目前的UI交互有点反人类，但是要改有点麻烦。我计划先完成场景创建逻辑以及序列化相关的东西，最后再一并完成交互优化和样式美化。

利用工厂类的方式实现组件类的反射。

## 静态成员函数

静态成员函数属于类本身，被子类继承时不会创建副本，通过子类类名调用的还是父类定义的那个函数，只有当子类重写（实际上是隐藏）这个函数时才会有一个副本（实际上就是两个不同的函数，实际上没有任何关系）。

## 延迟初始化

通过一个静态函数返回一个静态局部变量的引用，这就相当于一个延迟初始化的静态成员变量，只在函数第一次被调用时才初始化。

由于C++静态变量的初始化顺序是不确定的，当一个静态变量在初始化时用到了另一个静态变量，可能出现后者还没初始化的情况，这个时候就需要用到延迟初始化了。

## 静态变量的内存管理

如果静态变量中有动态申请的内存空间，虽然静态变量具有全局生命周期，在程序结束时没被手动释放的空间也会被回收，但这还是属于内存泄漏，某些情况下会出问题（比如dll被卸载了但是程序没结束）。所以需要在程序即将退出时调用清理函数，但这显然比较麻烦，这时候用智能指针就很合适。

# 7.23

继续完善编辑器

显示实体属性面板需要由组件ID或者组件指针得到组件类型名，还要确定转成哪种类型的组件指针，相当麻烦。直接硬编码了，至于是否该在编辑器中支持自定义组件，到时候再说。

目前感觉ECS架构好难用，可能考虑换架构。

场景的序列化和反序列化，这部分没有集成在scene类内部，而是单独封装了一个静态类，同时组件序列化器采用了哈希表存储函数指针的形式，保持组件类的纯粹性。

# 7.24

关于动画组件的序列化：我打算将帧动画整体作为一种资源，包括纹理图集以及元数据（解释纹理图集和动画属性）。

或许可以让动画组件不依附于精灵组件，让精灵组件表示场景中没有动画的精灵，让动画组件单独表示场景中有动画的精灵。现在动画的播放是通过改变精灵组件的textureRegion属性实现的。

用原始图片加元数据加载资源的方式还是有点不够优雅，或许可以将元数据写到图片文件头部合并成一个文件。

文件对话框：用win32API实现的。（跨平台适配时要处理）

## 宽字节和窄字节

窄字节：`char` 通常占1个字节

宽字节：`wchar_t` 通常是 2 字节或者 4 字节

在用Win32API实现文件对话框时，由于我的VS采用的Unicode字符集，win32API默认采用宽字节（OPENFILENAME被类型定义为OPENFIELNAMEW），于是我显式指定OPENFILENAMEA，不知道会不会有问题。

## 字符集、编码格式、宽字节和窄字节

**字符集**：字符的集合。一个单独的汉字，一个英文字母都是一个字符。规定了哪些字符可以在计算机中表示，每个字符对应一个唯一标识，称为码点。
**编码格式**（Encoding Format）是**将字符集中的字符转换为计算机可存储和传输的二进制数据的规则**

一对一：

| 字符集              | 唯一对应的编码格式 | 说明                                                         |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| ASCII               | ASCII 编码         | 128 个字符（英文字母、符号等），每个字符用 1 字节（7 位有效）表示。 |
| GB2312              | GB2312 编码        | 收录简体中文，汉字用 2 字节，ASCII 字符用 1 字节（兼容 ASCII）。 |
| GBK                 | GBK 编码           | 扩展 GB2312，包含繁体中文，编码规则与 GB2312 一致（1 字节 / 2 字节混合）。 |

Unicode的编码格式：

| 编码格式 | 与 Unicode 的关系                                            | 特点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| UTF-8    | 可变长度编码（1-4 字节），通过前缀位标识字节数（如 3 字节字符以`1110`开头）。 | 兼容 ASCII，节省空间（英文 1 字节），适合网络传输、文件存储（最常用）。 |
| UTF-16   | 基本字符用 2 字节，辅助平面字符（如表情）用 4 字节（代理对机制）。 | 适合大量非 ASCII 字符场景（如 Java、Windows 系统内部），索引效率高。 |
| UTF-32   | 固定 4 字节，直接存储 Unicode 码点（如 U+4E2D 直接存为`00004E2D`）。 | 编码 / 解码简单，但空间浪费大（英文也占 4 字节），极少用于存储。 |

**窄字节和宽字节** 
C++ 提供了四种字符类型，分别对应不同的编码方式：

| 类型       | 长度        | 用途                         | 示例                           |
| ---------- | ----------- | ---------------------------- | ------------------------------ |
| `char`     | 1 字节      | 窄字节，用于 ASCII 或 UTF-8  | `char str[] = "你好";`         |
| `wchar_t`  | 2 或 4 字节 | 宽字节，用于平台特定的宽字符 | `wchar_t wstr[] = L"你好";`    |
| `char16_t` | 2 字节      | UTF-16 编码                  | `char16_t u16str[] = u"你好";` |
| `char32_t` | 4 字节      | UTF-32 编码                  | `char32_t u32str[] = U"你好";` |
- `wchar_t`的长度取决于平台：
    - Windows：2 字节（UTF-16）
    
    - Linux/macOS：4 字节（UTF-32）
    

wchar_t 适用于固定长度编码，char 适用于可变长度编码，如utf-8。

# 7.25

重新写编辑器的应用程序类，不再用内核的Application类，有一些功能要自定义。

修复了几个Bug。

## 重复加载场景时崩溃

原因是加载新场景时实体卸载导致selectedEntity变成野指针。

解决方法是加载场景后selectedEntity置空。

## 重复加载场景时黑屏

出现一种很怪异的Bug，第一次加载场景时正常，第二次黑屏，第三次及以后都正常。偏偏只有第二次无法正常显示。

原因出在Renderer2D::init 和Renderer2D::shutdown函数，原代码中在RenderSystem的构造函数和析构函数中会分别调用这两个函数，重新加载场景时会删除旧的RenderSystem然后创建新的，导致Renderer2D::init被多次调用，而该函数中包含了许多静态变量的初始化，理论上只应该被调用一次。至于具体是怎么导致出现这种Bug我还不清楚。

# 7.26

资源管理面板：项目文件夹下Resouces目录，管理所有能被资源管理器直接加载的资源。

项目系统。

.cbproj文件：项目配置文件

.cube目录：资源依赖等其他文件

# 7.27

项目状态保存

编辑器中的Scene数据还要包含场景是否被保存等信息，但是这些信息与游戏中的场景本身无关，所以用结构体SceneData包装一层。

约定场景文件名必须与场景名相同。

有些成员函数(还有一些成员变量)CubeEngine内核不需要，而CubeEngine编辑器需要，考虑是否可以用条件编译的方式实现这一点。

保存机制还未完善。

# 7.28

完善保存机制：尝试了通过保存上一帧的场景对象的方式判断当前场景是否被更改，然后发现这是个大坑，需要实现Scene类的拷贝构造、复制操作符、比较操作符，并由此牵扯到Entity、component、system等很多类，遂放弃。决定先在每个修改处都设置标记来实现，后续可能要加入命令模式或者事件系统来管理修改操作，到时候比较好实现。还是太麻烦了，先放着吧。原来ImGui::InputText的返回值就是用户是否修改了数据，这下好了，问题完美解决。

为了编辑器需要在内核中加的函数越来越多，决定引入条件编译了（至少标注一下哪些函数是为编辑器加入的）。

# 7.29

资源管理面板

## 智能指针

遇到了一个程序结束时的异常，原因是将一个成员变量取地址传给了std::shared_ptr，当程序结束时，这个成员变量释放了，此时共享指针存的是一个野指针，而共享指针引用计数为零时会自动delete，导致程序崩溃。另一种可能是共享指针引用计数为零了，然后尝试释放这个成员变量导致程序崩溃。

# 7.30

继续资源管理面板，实现拖放功能。

# 7.31

场景视图中的鼠标键盘交互：

基本的已实现，还存在Bug：摄像机缩放或移动后点击选取实体的逻辑会出错（明天修）。

优化帧动画系统：将动画组件改成动画精灵组件，专门表示有动画的精灵，原本的精灵组件表示没有动画的精灵。（待办）

/bug

## 帧缓冲中的纹理旋转了180度

不通过帧缓冲显示的话没问题，通过帧缓冲显示出来纹理旋转了180度。

就很奇怪，坐标系什么的都正常，就单单里面的纹理是旋转的，这么一看好像不是帧缓冲的问题，而是渲染在帧缓冲中的纹理的问题，然而以同样的方式直接在屏幕上渲染纹理就是正常的。在SandBox项目里用帧缓冲渲染同样的场景，直接将帧缓冲渲染在屏幕上(不以纹理的形式)也没问题。

问了AI，AI分析半天不知道是什么原因，倒是提出了一些一看就错的修改方案。

``````C++
ImGui::Image(frameBuffer->getTexture(), sceneViewSize, ImVec2(0, 1), ImVec2(1, 0));
``````

AI提出把后两个参数改成{0, 0}和{1, 1}，也就是不应用上下翻转，结果就是坐标系对不上了，变成了以左上角为原点，于是我把它改回去，再运行，这下又能正常显示了。

找到原因了，TextureRegion属性的uvMin和uvMax搞反了。。。越玄的BUG往往是越朴素的原因。

## 系统崩溃导致电脑重启

程序运行几秒后开始变得无响应，弹出了一个报错框，(因为无响应所以我终止程序的机会都没有)然后黑屏，然后重合。

原因是我打算调试上面那个问题时，在堆上创建了一个TextureAlas对象通过ImGui::Image渲染，想着只是调试就没有删除，然而我没有发现这行代码是写在渲染循环里的，导致内存泄漏越来越多，但最主要的应该是不断创建纹理把显存给爆了，当然因为我用的是集显，显存就是共享的系统内存，结果应该就是系统内存耗尽触发了某种硬件保护机制导致重启。

当然以上都是我的猜想，我很想知道具体是什么情况，但我实在是不敢复刻了。

这次的崩溃让我对Windows的保护机制产生了怀疑，怎么能让一个程序耗尽整个系统内存呢，换句话说不应该是操作系统给程序分配有限的内存空间吗，而且当一个程序这样异常地占用了巨量的内存时系统不应该出手终止程序吗，当然也可能是显卡驱动的锅。不管怎么说，一个程序Bug导致系统重启还是有点离谱。

单纯的内存泄漏是不会导致重启的，只是程序会崩溃

``````C++
#include <iostream>
int main() {
    while (true) {
        int* x = new int[10000];
        std::cout << "Hello, World!\n";
    }
    return 0;
}
``````

输出：

terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc

表示内存分配失败，只会导致应用层面的崩溃。

# 8.1

/progress

修复了选取实体的bug

# 8.3

/todo

将编辑器的场景视图的渲染和实际游戏渲染分开，编辑器场景的渲染系统有单独的编辑器相机，可以随意漫游，增加播放按钮，点击后打开一个窗口预览实际游戏画面。

/idea

写一个小软件，记录项目开发的进度、待办、Bug、灵感等。 // discard

# 8.4

/idea

写一个软件还是没必要，用斜杠标签这样的形式进行分类标注就行了，可以写一个脚本把相同分类标签的内容抽离出来组成一个独立的md文档方便查看。

/progress

编辑器相机，编辑器渲染系统

# 8.5

/todo

渲染器类(Renderer和Renderer2D)那些静态函数封装得不太好，得重新整一下。

/bug

## 共享上下文问题

我创建了一个播放按钮，点击后创建一个窗口，该窗口共享的主窗口上下文，窗口中渲染实际游戏场景，但是这个窗口中渲染不出任何场景内容，经过调试推测是没能成功访问到主窗口上下文中的资源。问AI得知，必须先创建共享窗口，再创建资源才能被访问到，创建共享窗口前创建的资源是访问不到的。然而经过初步调试，把游戏窗口改到和主窗口同时创建，还是没能渲染出来。

/todo

我决定还是不共享上下文了，为每个窗口创建独立的上下文资源。

# 8.6

/progress

创建了一个Context类，将着色器、VBO等资源放在这个类里，将其作为Window类的一个成员，渲染器的初始化都在Window类的初始化中完成。也就是每个窗口拥有独立的上下文资源。

/bug

关闭游戏窗口后编辑器的场景视图中的场景也渲染不出来了，有的时候第一次关闭窗口就渲染不了，有的时候要多次关闭窗口才会无法渲染。在游戏窗口存在时点击play按钮会百分百触发这个bug。

经过近半天的调试终于找到原因，简单来说就是在错误的上下文中释放了资源。当游戏窗口存在并点击play按钮时，此时的上下文是主窗口，这时候销毁游戏窗口的上下文时，会执行其中shader、whitetex、vbo、vao等对象的析构，这些析构就是简单的glDelete函数，但是由于此时在主窗口上下文中，所以就用游戏窗口上下文中创建的对象ID释放了主窗口上下文中的资源，导致主窗口无法正常渲染。解决办法很简单，在删除之前手动切换到游戏窗口上下文就行了。

还有一个隐患，Context类中shader等成员是用共享指针管理的，可能会有问题，因为我不知道context对象销毁时这些对象是否会被销毁，如果在其他地方被释放，就不能保证其在正确的上下文中释放。

这种图形的东西调试起来是真的坐牢，一点报错信息都没有。

/todo

目前带纹理的东西还无法在游戏窗口中显示，原因是依赖资源管理器的纹理只会被创建一份，这一份在主窗口中，要在游戏窗口上下文中在创建一份。

# 8.7

/todo /done

游戏窗口还是不能与编辑器的渲染逻辑太过耦合，要将其作为一个独立的线程，将资源也尽可能独立出来，不和主线程共享，最好做到把这些部分抽离出来就是一个独立的游戏程序的程度。

上下文是和线程绑定的，把编辑器程序和游戏程序放到两个线程就不用切换上下文了。

/progress

将游戏窗口作为了一个子线程，以后这个线程就是Debug模式下的游戏预览。

/todo/done

目前游戏窗口中的纹理还无法正常显示，为编辑创建一个单独的资源管理器，原本的资源管理器应该只用于实际游戏程序。

# 8.8

/todo/done

资源管理器不使用单例模式，将其作为上下文类的一个成员。

/progress

游戏窗口已完成

/todo

加入资源预览窗口。加入纹理图集分割功能，元数据保存成同名.json文件。向实体附着纹理时判断是否有元数据，没有则附着整个纹理，有则由用户选择附着哪个区域。

/note

## ImGui中的ID

ImGui中不同窗口（ImGui窗口）中的ID是可以重复的。
