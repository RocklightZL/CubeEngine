记录整个项目的开发过程，包括想法、bug等。

从7.20开始记录（项目从7.3开始开发）。

# 7.20

开始开发CubeEditor

用**imgui**开发编辑器。

## 拖动imgui演示窗口出现拖影

原因是没有清除颜色缓冲区。

清除颜色缓冲区的代码放在了RenderSystem的更新逻辑里，而我不打算让编辑器的本身的UI渲染依赖于引擎内核的ECS架构，所以这部分代码应该放在Application循环的最开始。

# 7.21

完成了FrameBuffer封装，实现了基本的场景视图和场景面板。

## imgui复选框

checkbox第二个参数（也就是表示是否选中的bool变量指针）对应的bool变量初始化不能放在渲染循环里，否则点击复选框没反应，原因是状态每次都被重置了。

## ImGui对话框显示逻辑

OpenPopup() 将指定对话框标识为“需要显示”，即激活状态。

BeginPopup(): 当该对话框处于激活状态时返回true，显示内容，不处于激活状态时返回false，不显示。

CloseCurrentPopup(): 将当前对话框标识为“不显示”，即未激活状态。

当在一个对话框里调用OpenPopup() 意为打开一个子对话框，并且子对话框逻辑必须在父对话框内部，当父对话框退出时，子对话框也会退出。这就是不能把对话框逻辑写在右键菜单中的原因。

# 7.22

继续完善场景创建逻辑

目前的UI交互有点反人类，但是要改有点麻烦。我计划先完成场景创建逻辑以及序列化相关的东西，最后再一并完成交互优化和样式美化。

利用工厂类的方式实现组件类的反射。

## 静态成员函数

静态成员函数属于类本身，被子类继承时不会创建副本，通过子类类名调用的还是父类定义的那个函数，只有当子类重写（实际上是隐藏）这个函数时才会有一个副本（实际上就是两个不同的函数，实际上没有任何关系）。

## 延迟初始化

通过一个静态函数返回一个静态局部变量的引用，这就相当于一个延迟初始化的静态成员变量，只在函数第一次被调用时才初始化。

由于C++静态变量的初始化顺序是不确定的，当一个静态变量在初始化时用到了另一个静态变量，可能出现后者还没初始化的情况，这个时候就需要用到延迟初始化了。

## 静态变量的内存管理

如果静态变量中有动态申请的内存空间，虽然静态变量具有全局生命周期，在程序结束时没被手动释放的空间也会被回收，但这还是属于内存泄漏，某些情况下会出问题（比如dll被卸载了但是程序没结束）。所以需要在程序即将退出时调用清理函数，但这显然比较麻烦，这时候用智能指针就很合适。

# 7.23

继续完善编辑器

显示实体属性面板需要由组件ID或者组件指针得到组件类型名，还要确定转成哪种类型的组件指针，相当麻烦。直接硬编码了，至于是否该在编辑器中支持自定义组件，到时候再说。

目前感觉ECS架构好难用，可能考虑换架构。

场景的序列化和反序列化，这部分没有集成在scene类内部，而是单独封装了一个静态类，同时组件序列化器采用了哈希表存储函数指针的形式，保持组件类的纯粹性。

# 7.24

关于动画组件的序列化：我打算将帧动画整体作为一种资源，包括纹理图集以及元数据（解释纹理图集和动画属性）。

或许可以让动画组件不依附于精灵组件，让精灵组件表示场景中没有动画的精灵，让动画组件单独表示场景中有动画的精灵。现在动画的播放是通过改变精灵组件的textureRegion属性实现的。

用原始图片加元数据加载资源的方式还是有点不够优雅，或许可以将元数据写到图片文件头部合并成一个文件。

文件对话框：用win32API实现的。（跨平台适配时要处理）

## 宽字节和窄字节

窄字节：`char` 通常占1个字节

宽字节：`wchar_t` 通常是 2 字节或者 4 字节

在用Win32API实现文件对话框时，由于我的VS采用的Unicode字符集，win32API默认采用宽字节（OPENFILENAME被类型定义为OPENFIELNAMEW），于是我显式指定OPENFILENAMEA，不知道会不会有问题。

## 字符集、编码格式、宽字节和窄字节

**字符集**：字符的集合。一个单独的汉字，一个英文字母都是一个字符。规定了哪些字符可以在计算机中表示，每个字符对应一个唯一标识，称为码点。
**编码格式**（Encoding Format）是**将字符集中的字符转换为计算机可存储和传输的二进制数据的规则**

一对一：

| 字符集              | 唯一对应的编码格式 | 说明                                                         |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| ASCII               | ASCII 编码         | 128 个字符（英文字母、符号等），每个字符用 1 字节（7 位有效）表示。 |
| GB2312              | GB2312 编码        | 收录简体中文，汉字用 2 字节，ASCII 字符用 1 字节（兼容 ASCII）。 |
| GBK                 | GBK 编码           | 扩展 GB2312，包含繁体中文，编码规则与 GB2312 一致（1 字节 / 2 字节混合）。 |

Unicode的编码格式：

| 编码格式 | 与 Unicode 的关系                                            | 特点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| UTF-8    | 可变长度编码（1-4 字节），通过前缀位标识字节数（如 3 字节字符以`1110`开头）。 | 兼容 ASCII，节省空间（英文 1 字节），适合网络传输、文件存储（最常用）。 |
| UTF-16   | 基本字符用 2 字节，辅助平面字符（如表情）用 4 字节（代理对机制）。 | 适合大量非 ASCII 字符场景（如 Java、Windows 系统内部），索引效率高。 |
| UTF-32   | 固定 4 字节，直接存储 Unicode 码点（如 U+4E2D 直接存为`00004E2D`）。 | 编码 / 解码简单，但空间浪费大（英文也占 4 字节），极少用于存储。 |

**窄字节和宽字节** 
C++ 提供了四种字符类型，分别对应不同的编码方式：

| 类型       | 长度        | 用途                         | 示例                           |
| ---------- | ----------- | ---------------------------- | ------------------------------ |
| `char`     | 1 字节      | 窄字节，用于 ASCII 或 UTF-8  | `char str[] = "你好";`         |
| `wchar_t`  | 2 或 4 字节 | 宽字节，用于平台特定的宽字符 | `wchar_t wstr[] = L"你好";`    |
| `char16_t` | 2 字节      | UTF-16 编码                  | `char16_t u16str[] = u"你好";` |
| `char32_t` | 4 字节      | UTF-32 编码                  | `char32_t u32str[] = U"你好";` |
- `wchar_t`的长度取决于平台：
    - Windows：2 字节（UTF-16）
    
    - Linux/macOS：4 字节（UTF-32）
    

wchar_t 适用于固定长度编码，char 适用于可变长度编码，如utf-8。

# 7.25

重新写编辑器的应用程序类，不再用内核的Application类，有一些功能要自定义。

修复了几个Bug。

## 重复加载场景时崩溃

原因是加载新场景时实体卸载导致selectedEntity变成野指针。

解决方法是加载场景后selectedEntity置空。

## 重复加载场景时黑屏

出现一种很怪异的Bug，第一次加载场景时正常，第二次黑屏，第三次及以后都正常。偏偏只有第二次无法正常显示。

原因出在Renderer2D::init 和Renderer2D::shutdown函数，原代码中在RenderSystem的构造函数和析构函数中会分别调用这两个函数，重新加载场景时会删除旧的RenderSystem然后创建新的，导致Renderer2D::init被多次调用，而该函数中包含了许多静态变量的初始化，理论上只应该被调用一次。至于具体是怎么导致出现这种Bug我还不清楚。

# 7.26

资源管理面板：项目文件夹下Resouces目录，管理所有能被资源管理器直接加载的资源。

项目系统。

.cbproj文件：项目配置文件

.cube目录：资源依赖等其他文件

# 7.27

项目状态保存

编辑器中的Scene数据还要包含场景是否被保存等信息，但是这些信息与游戏中的场景本身无关，所以用结构体SceneData包装一层。

约定场景文件名必须与场景名相同。

有些成员函数(还有一些成员变量)CubeEngine内核不需要，而CubeEngine编辑器需要，考虑是否可以用条件编译的方式实现这一点。

保存机制还未完善。

# 7.28

完善保存机制：尝试了通过保存上一帧的场景对象的方式判断当前场景是否被更改，然后发现这是个大坑，需要实现Scene类的拷贝构造、复制操作符、比较操作符，并由此牵扯到Entity、component、system等很多类，遂放弃。决定先在每个修改处都设置标记来实现，后续可能要加入命令模式或者事件系统来管理修改操作，到时候比较好实现。还是太麻烦了，先放着吧。原来ImGui::InputText的返回值就是用户是否修改了数据，这下好了，问题完美解决。

为了编辑器需要在内核中加的函数越来越多，决定引入条件编译了（至少标注一下哪些函数是为编辑器加入的）。

# 7.29

资源管理面板

## 智能指针

遇到了一个程序结束时的异常，原因是将一个成员变量取地址传给了std::shared_ptr，当程序结束时，这个成员变量释放了，此时共享指针存的是一个野指针，而共享指针引用计数为零时会自动delete，导致程序崩溃。另一种可能是共享指针引用计数为零了，然后尝试释放这个成员变量导致程序崩溃。

# 7.30

继续资源管理面板，实现拖放功能。
