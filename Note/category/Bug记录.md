此文档包含所有标记为 `Bug记录` 的内容，按日期排序：

---

# 7.31

## 帧缓冲中的纹理旋转了180度
不通过帧缓冲显示的话没问题，通过帧缓冲显示出来纹理旋转了180度。
就很奇怪，坐标系什么的都正常，就单单里面的纹理是旋转的，这么一看好像不是帧缓冲的问题，而是渲染在帧缓冲中的纹理的问题，然而以同样的方式直接在屏幕上渲染纹理就是正常的。在SandBox项目里用帧缓冲渲染同样的场景，直接将帧缓冲渲染在屏幕上(不以纹理的形式)也没问题。
问了AI，AI分析半天不知道是什么原因，倒是提出了一些一看就错的修改方案。
``````C++
ImGui::Image(frameBuffer->getTexture(), sceneViewSize, ImVec2(0, 1), ImVec2(1, 0));
``````
AI提出把后两个参数改成{0, 0}和{1, 1}，也就是不应用上下翻转，结果就是坐标系对不上了，变成了以左上角为原点，于是我把它改回去，再运行，这下又能正常显示了。
找到原因了，TextureRegion属性的uvMin和uvMax搞反了。。。越玄的BUG往往是越朴素的原因。
## 系统崩溃导致电脑重启
程序运行几秒后开始变得无响应，弹出了一个报错框，(因为无响应所以我终止程序的机会都没有)然后黑屏，然后重合。
原因是我打算调试上面那个问题时，在堆上创建了一个TextureAlas对象通过ImGui::Image渲染，想着只是调试就没有删除，然而我没有发现这行代码是写在渲染循环里的，导致内存泄漏越来越多，但最主要的应该是不断创建纹理把显存给爆了，当然因为我用的是集显，显存就是共享的系统内存，结果应该就是系统内存耗尽触发了某种硬件保护机制导致重启。
当然以上都是我的猜想，我很想知道具体是什么情况，但我实在是不敢复刻了。
这次的崩溃让我对Windows的保护机制产生了怀疑，怎么能让一个程序耗尽整个系统内存呢，换句话说不应该是操作系统给程序分配有限的内存空间吗，而且当一个程序这样异常地占用了巨量的内存时系统不应该出手终止程序吗，当然也可能是显卡驱动的锅。不管怎么说，一个程序Bug导致系统重启还是有点离谱。
单纯的内存泄漏是不会导致重启的，只是程序会崩溃
``````C++
#include <iostream>
int main() {
    while (true) {
        int* x = new int[10000];
        std::cout << "Hello, World!\n";
    }
    return 0;
}
``````
输出：
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
表示内存分配失败，只会导致应用层面的崩溃。

---